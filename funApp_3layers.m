clc
clear all

f = @(x)2./(1+exp(-2*x))-1;                 % activation function for hidden layer
Df = @(x)4*exp(-2*x)./(1+exp(-2*x)).^2;     % derivation of activation function

x = (-10:0.2:10)';
d = sinc(2*x)-0.4*cos(3*x)+0.2*sin(2*x-50)-0.3*sin(0.5*x-5); % sample data generated by unknown function

n = length(x);
m = length(d);
L1 = 30;
L2 = 20;

% weight matrices
w1 = 0.01*ones(L1, n);
w2 = 0.01*ones(L2, L1);
w3 = 0.01*ones(m, L2);

v1=w1*x; y1=f(v1); v2=w2*y1; y2=f(v2); v3=w3*y2; y3=f(v3);

g = figure(1);
g.Position = [70 50 1250 600];
h = plot(x, d, 'o', x, y3, '--');
axis([min(x) max(x) min(d)-0.5 max(d)+0.5]);

eTol = 1e-4;        % tolerance for total error
eta = 0.01;         % learning rate

% momentum for each weights
mmt1 = 0;           
mmt2 = 0;
mmt3 = 0;

beta = 0.5; % momentum rate
epoch = 0;

while(1)

    % forward calculation
    v1=w1*x;
    y1=f(v1);
    v2=w2*y1;
    y2=f(v2);
    v3=w3*y2;
    y3=f(v3);
    
    e3 = d - y3;
    d3 = e3.*Df(v3);
    dw3 = eta*d3*y2';
    
    % backward propagation
    e2 = w3'*d3;
    d2 = e2.*Df(v2);
    dw2 = eta*d2*y1';
    
    e1 = w2'*d2;
    d1 = e1.*Df(v1);
    dw1 = eta*d1*x';
    
    mmt1 = dw1 + beta*mmt1;
    mmt2 = dw2 + beta*mmt2;
    mmt3 = dw3 + beta*mmt3;

    % weight updates
    w1 = w1 + mmt1;
    w2 = w2 + mmt2;
    w3 = w3 + mmt3;
    
    % calulate error
    E = 0.5*e3'*e3;
    if E< eTol
        break;
    end

    % draw
    if mod(epoch,2)==0
        h(2).YData = y3;
        drawnow;
    end
    epoch = epoch + 1;
end
